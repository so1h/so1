JWasm v2.12pre, Nov 27 2013
ASM\H_LDIV.ASM
                                ;[]-----------------------------------------------------------------[]
                                ;|      H_LDIV.ASM -- long division routine                          |
                                ;[]-----------------------------------------------------------------[]

                                ;
                                ;       C/C++ Run Time Library - Version 5.0
                                ;
                                ;       Copyright (c) 1987, 1992 by Borland International
                                ;       All Rights Reserved.
                                ;

                                ;       INCLUDE RULES.ASI

00000000                        _TEXT   segment public byte 'CODE'
                                        assume  cs:_TEXT
                                        public  LDIV@
                                        public  F_LDIV@
                                        public  N_LDIV@
                                        public  LUDIV@
                                        public  F_LUDIV@
                                        public  N_LUDIV@
                                        public  LMOD@
                                        public  F_LMOD@
                                        public  N_LMOD@
                                        public  LUMOD@
                                        public  F_LUMOD@
                                        public  N_LUMOD@

00000000                        N_LDIV@:
00000000  59                            pop     cx                      ;fix up far return
00000001  0E                            push    cs
00000002  51                            push    cx
00000003                        LDIV@:
00000003                        F_LDIV@:
00000003  33C9                          xor     cx,cx                   ; signed divide
00000005  EB16                          jmp     short common

00000007                        N_LUDIV@:
00000007  59                            pop     cx                      ;fix up far return
00000008  0E                            push    cs
00000009  51                            push    cx
0000000A                        LUDIV@:
0000000A                        F_LUDIV@:
0000000A  B90100                        mov     cx,1                    ; unsigned divide
0000000D  EB0E                          jmp     short common

0000000F                        N_LMOD@:
0000000F  59                            pop     cx                      ;fix up far return
00000010  0E                            push    cs
00000011  51                            push    cx
00000012                        LMOD@:
00000012                        F_LMOD@:
00000012  B90200                        mov     cx,2                    ; signed remainder
00000015  EB06                          jmp     short   common

00000017                        N_LUMOD@:
00000017  59                            pop     cx                      ;fix up far return
00000018  0E                            push    cs
00000019  51                            push    cx
0000001A                        LUMOD@:
0000001A                        F_LUMOD@:
0000001A  B90300                        mov     cx,3                    ; unsigned remainder

                                ;
                                ;       di now contains a two bit control value.  The low order
                                ;       bit (test mask of 1) is on if the operation is unsigned,
                                ;       signed otherwise.  The next bit (test mask of 2) is on if
                                ;       the operation returns the remainder, quotient otherwise.
                                ;
0000001D                        common:
0000001D  55                            push    bp
0000001E  56                            push    si
0000001F  57                            push    di
00000020  8BEC                          mov     bp,sp                   ; set up frame
00000022  8BF9                          mov     di,cx
                                ;
                                ;       dividend is pushed last, therefore the first in the args
                                ;       divisor next.
                                ;
00000024  8B460A                        mov     ax,10[bp]               ; get the first low word
00000027  8B560C                        mov     dx,12[bp]               ; get the first high word
0000002A  8B5E0E                        mov     bx,14[bp]               ; get the second low word
0000002D  8B4E10                        mov     cx,16[bp]               ; get the second high word

00000030  0BC9                          or      cx,cx
00000032  7508                          jnz     slow@ldiv               ; both high words are zero

00000034  0BD2                          or      dx,dx
00000036  7469                          jz      quick@ldiv

00000038  0BDB                          or      bx,bx
0000003A  7465                          jz      quick@ldiv              ; if cx:bx == 0 force a zero divide
                                                                        ; we don't expect this to actually
                                                                        ; work

0000003C                        slow@ldiv:

0000003C  F7C70100                      test    di,1                    ; signed divide?
00000040  751C                          jnz     positive                ; no: skip
                                ;
                                ;               Signed division should be done.  Convert negative
                                ;               values to positive and do an unsigned division.
                                ;               Store the sign value in the next higher bit of
                                ;               di (test mask of 4).  Thus when we are done, testing
                                ;               that bit will determine the sign of the result.
                                ;
00000042  0BD2                          or      dx,dx                   ; test sign of dividend
00000044  790A                          jns     onepos
00000046  F7DA                          neg     dx
00000048  F7D8                          neg     ax
0000004A  83DA00                        sbb     dx,0                    ; negate dividend
0000004D  83CF0C                        or      di,0Ch
00000050                        onepos:
00000050  0BC9                          or      cx,cx                   ; test sign of divisor
00000052  790A                          jns     positive
00000054  F7D9                          neg     cx
00000056  F7DB                          neg     bx
00000058  83D900                        sbb     cx,0                    ; negate divisor
0000005B  83F704                        xor     di,4
0000005E                        positive:
0000005E  8BE9                          mov     bp,cx
00000060  B92000                        mov     cx,32                   ; shift counter
00000063  57                            push    di                      ; save the flags
                                ;
                                ;       Now the stack looks something like this:
                                ;
                                ;               16[bp]: divisor (high word)
                                ;               14[bp]: divisor (low word)
                                ;               12[bp]: dividend (high word)
                                ;               10[bp]: dividend (low word)
                                ;                8[bp]: return CS
                                ;                6[bp]: return IP
                                ;                4[bp]: previous BP
                                ;                2[bp]: previous SI
                                ;                 [bp]: previous DI
                                ;               -2[bp]: control bits
                                ;                       01 - Unsigned divide
                                ;                       02 - Remainder wanted
                                ;                       04 - Negative quotient
                                ;                       08 - Negative remainder
                                ;
00000064  33FF                          xor     di,di                   ; fake a 64 bit dividend
00000066  33F6                          xor     si,si                   ;
00000068                        xloop:
00000068  D1E0                          shl     ax,1                    ; shift dividend left one bit
0000006A  D1D2                          rcl     dx,1
0000006C  D1D6                          rcl     si,1
0000006E  D1D7                          rcl     di,1
00000070  3BFD                          cmp     di,bp                   ; dividend larger?
00000072  720B                          jb      nosub
00000074  7704                          ja      subtract
00000076  3BF3                          cmp     si,bx                   ; maybe
00000078  7205                          jb      nosub
0000007A                        subtract:
0000007A  2BF3                          sub     si,bx
0000007C  1BFD                          sbb     di,bp                   ; subtract the divisor
0000007E  40                            inc     ax                      ; build quotient
0000007F                        nosub:
0000007F  E2E7                          loop    xloop
                                ;
                                ;       When done with the loop the four register value look like:
                                ;
                                ;       |     di     |     si     |     dx     |     ax     |
                                ;       |        remainder        |         quotient        |
                                ;
00000081  5B                            pop     bx                      ; get control bits
00000082  F7C30200                      test    bx,2                    ; remainder?
00000086  7406                          jz      usequo
00000088  8BC6                          mov     ax,si
0000008A  8BD7                          mov     dx,di                   ; use remainder
0000008C  D1EB                          shr     bx,1                    ; shift in the remainder sign bit
0000008E                        usequo:
0000008E  F7C30400                      test    bx,4                    ; needs negative
00000092  7407                          jz      finish
00000094  F7DA                          neg     dx
00000096  F7D8                          neg     ax
00000098  83DA00                        sbb     dx,0                    ; negate
0000009B                        finish:
0000009B  5F                            pop     di
0000009C  5E                            pop     si
0000009D  5D                            pop     bp
0000009E  CA0800                        retf    8

000000A1                        quick@ldiv:
000000A1  F7F3                          div     bx                      ; unsigned divide
                                                                        ; DX = remainder AX = quotient
000000A3  F7C70200                      test    di,2                    ; want remainder?
000000A7  7401                          jz      quick@quo
000000A9  92                            xchg    ax,dx

000000AA                        quick@quo:

000000AA  33D2                          xor     dx,dx
000000AC  EBED                          jmp     short finish

000000AE                        _TEXT   ends
                                        end


Macros:

                N a m e                 Type

@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

$$SYMBOLS  . . . . . . . . . . .        32 Bit   000001B1 Byte    Private 'DEBSYM'
$$TYPES  . . . . . . . . . . . .        32 Bit   00000004 Byte    Private 'DEBTYP'
_TEXT  . . . . . . . . . . . . .        16 Bit   00AE     Byte    Public  'CODE'


Symbols:

                N a m e                 Type       Value     Attr

??version  . . . . . . . . . . .        Text   0504
?debug . . . . . . . . . . . . .        Text   ;
F_LDIV@  . . . . . . . . . . . .        L Near             3h _TEXT Public 
F_LMOD@  . . . . . . . . . . . .        L Near            12h _TEXT Public 
F_LUDIV@ . . . . . . . . . . . .        L Near             Ah _TEXT Public 
F_LUMOD@ . . . . . . . . . . . .        L Near            1Ah _TEXT Public 
LDIV@  . . . . . . . . . . . . .        L Near             3h _TEXT Public 
LMOD@  . . . . . . . . . . . . .        L Near            12h _TEXT Public 
LUDIV@ . . . . . . . . . . . . .        L Near             Ah _TEXT Public 
LUMOD@ . . . . . . . . . . . . .        L Near            1Ah _TEXT Public 
N_LDIV@  . . . . . . . . . . . .        L Near             0h _TEXT Public 
N_LMOD@  . . . . . . . . . . . .        L Near             Fh _TEXT Public 
N_LUDIV@ . . . . . . . . . . . .        L Near             7h _TEXT Public 
N_LUMOD@ . . . . . . . . . . . .        L Near            17h _TEXT Public 
common . . . . . . . . . . . . .        L Near            1Dh _TEXT 
finish . . . . . . . . . . . . .        L Near            9Bh _TEXT 
nosub  . . . . . . . . . . . . .        L Near            7Fh _TEXT 
onepos . . . . . . . . . . . . .        L Near            50h _TEXT 
positive . . . . . . . . . . . .        L Near            5Eh _TEXT 
quick@ldiv . . . . . . . . . . .        L Near            A1h _TEXT 
quick@quo  . . . . . . . . . . .        L Near            AAh _TEXT 
slow@ldiv  . . . . . . . . . . .        L Near            3Ch _TEXT 
subtract . . . . . . . . . . . .        L Near            7Ah _TEXT 
usequo . . . . . . . . . . . . .        L Near            8Eh _TEXT 
xloop  . . . . . . . . . . . . .        L Near            68h _TEXT 

ASM\H_LDIV.ASM: 197 lines, 2 passes, 0 ms, 0 warnings, 0 errors
