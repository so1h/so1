JWasm v2.12pre, Nov 27 2013
pbrfat12.asm
                                	.286
                                	ifndef	??version
                                	else
                                $comm	macro	name,dist,size,count
 >                              	comm	dist name[size]:BYTE:count
 >                              	endm
                                	endif
00000000                        _TEXT	segment byte public 'CODE'
                                _TEXT	ends
                                DGROUP	group	_DATA,_BSS
                                	assume	cs:_TEXT,ds:DGROUP
00000000                        _DATA	segment word public 'DATA'
00000000                        d@	label	byte
00000000                        d@w	label	word
00000000                        _DATA	ends
00000000                        _BSS	segment word public 'BSS'
00000000                        b@	label	byte
00000000                        b@w	label	word
00000000                        _BSS	ends
00000000                        _DATA	segment word public 'DATA'
00000000                         	_DATA	 ENDS 
00000000                         	_TEXT	 SEGMENT BYTE PUBLIC 'CODE' 
                                 	ASSUME	 CS:_TEXT,DS:DGROUP 
00000000                         	_startBin	 PROC NEAR 
00000000  EB3C                   	jmp	 short _bootCode 
00000002  90                     	nop	 
                                 	org	 0003EH 
                                 	;	 
0000003E                         	_startBin	 ENDP 
0000003E                         	_TEXT	 ENDS 
                                 	public	 _startBin 
00000000                         	_DATA	 SEGMENT WORD PUBLIC 'DATA' 
00000000                        _DATA	ends
0000003E                        _TEXT	segment byte public 'CODE'
                                	assume	cs:_TEXT,ds:DGROUP
0000003E                        _bootCode	proc	near
                                   ;	
                                   ;	void bootCode ( void ) {                  /* recibe el cotrol desde el BPB */
                                   ;	
                                   ;	
                                   ;	  asm {
                                   ;	//  cli ;        /* inhibimos las interrupciones (se suponen ya inhibidas) */
                                   ;	    mov sp,0x9000 ;              /* establecemos la pila SS:SP = 9000:9000 */
                                   ;	
0000003E  BC0090                	mov	 sp,09000H 
                                   ;	
                                   ;	    mov ss,sp ;                                         /* por simplicidad */
                                   ;	
00000041  8ED4                  	mov	 ss,sp 
                                   ;	
                                   ;	//  mov bp,sp ;                                       /* SS:BP = 9000:9000 */
                                   ;	//  sti ;                   /* permitimos las interrupciones (innecesario) */
                                   ;	
                                   ;	#if (CARGA7C00)
                                   ;	    mov ax,7c00h SHR 4 ;                                            /* 7C0 */
                                   ;	
00000043  B8C007                	mov	 ax,7c00h SHR 4 
                                   ;	
                                   ;	#else              /* funciona con carga del sector en cualquier paragrafo */
                                   ;	                     /* lo que es util para depurar PBRFAT16.EXE con el TD */
                                   ;	             /* Se presupone IP alineado a paragrafo: IP & 0x000F = 0x0000 */
                                   ;	    call $+3 ;                         /* apilamos la dirección de retorno */
                                   ;	    pop bx ;                           /* BX = IP de pop bx                */
                                   ;	    sub bx,$-1 ;                       /* BX = IP donde se cargo el sector */
                                   ;	    shr bx,4 ;
                                   ;	    mov ax,cs ;
                                   ;	    add ax,bx ;            /* AX:0000 = direccion donde se cargo el sector */
                                   ;	#endif
                                   ;	    mov ds,ax ;
                                   ;	
00000046  8ED8                  	mov	 ds,ax 
                                   ;	
                                   ;	    push ax ;
                                   ;	
00000048  50                    	push	 ax 
                                   ;	
                                   ;	#if defined(JWASM) || defined(TASM32)
                                   ;	    push OFFSET main ;                                /* retornamos a main */
                                   ;	
00000049  681801                	push	 OFFSET _main 
                                   ;	
                                   ;	#else
                                   ;	    mov ax,OFFSET main ;
                                   ;	    push ax ;
                                   ;	#endif
                                   ;	    retf ;                                 /* retorno lejano (a 07C0:main) */
                                   ;	
0000004C  CB                    	retf	 
                                   ;	
                                   ;	  }                                             /* estableciendo CS a 07C0 */
                                   ;	}
                                   ;	
0000004D                        	ret	
0000004E                        _bootCode	endp
                                	assume	cs:_TEXT,ds:DGROUP
0000004E                        _printCar	proc	near
                                   ;	
                                   ;	void printCar ( char car ) {
                                   ;	
0000004E  55                    	push	bp
0000004F  8BEC                  	mov	bp,sp
                                   ;	
                                   ;	  asm {
                                   ;	    mov al,car           /* car -> caracter a escribir                     */
                                   ;	
00000051  8A4604                	mov	 al,[bp+4]           
                                   ;	
                                   ;	    mov ah,0eH           /* 0eH -> escribir caracter                       */
                                   ;	
00000054  B40E                  	mov	 ah,0eH           
                                   ;	
                                   ;	    int 10H              /* 10H -> servicios BIOS de manejo de la pantalla */
                                   ;	
00000056  CD10                  	int	 10H              
                                   ;	
                                   ;	  }
                                   ;	}
                                   ;	
00000058  5D                    	pop	bp
00000059                        	ret	
0000005A                        _printCar	endp
                                	assume	cs:_TEXT,ds:DGROUP
0000005A                        _printStr	proc	near
                                   ;	
                                   ;	void printStr ( char * str ) {
                                   ;	
0000005A  C8020000              	enter	2,0
0000005E  EB14                  	jmp	short @3@5
00000060                        @3@2:
                                   ;	
                                   ;	  char car ;
                                   ;	  while ((car = *str++) != (char)0) {
                                   ;	    if (car == '\n') printCar('\r') ;
                                   ;	
00000060  807EFF0A              	cmp	byte ptr [bp-1],10
00000064  7506                  	jne	short @3@4
00000066  6A0D                  	push	13
00000068  E8E3FF                	call	near ptr _printCar
0000006B  59                    	pop	cx
0000006C                        @3@4:
                                   ;	
                                   ;	    printCar(car) ;
                                   ;	
0000006C  8A46FF                	mov	al,byte ptr [bp-1]
0000006F  50                    	push	ax
00000070  E8DBFF                	call	near ptr _printCar
00000073  59                    	pop	cx
00000074                        @3@5:
00000074  8B5E04                	mov	bx,word ptr [bp+4]
00000077  FF4604                	inc	word ptr [bp+4]
0000007A  8A07                  	mov	al,byte ptr [bx]
0000007C  8846FF                	mov	byte ptr [bp-1],al
0000007F  0AC0                  	or	al,al
00000081  75DD                  	jne	short @3@2
                                   ;	
                                   ;	  }
                                   ;	}
                                   ;	
00000083  C9                    	leave	
00000084                        	ret	
00000085                        _printStr	endp
                                	assume	cs:_TEXT,ds:DGROUP
00000085                        _leerTecla	proc	near
                                   ;	
                                   ;	char leerTecla ( void ) {
                                   ;	
                                   ;	
                                   ;	//char car ;
                                   ;	  asm {
                                   ;	    mov ah,00H                  /* 00H -> leer siguiente tecla pulsada     */
                                   ;	
00000085  B400                  	mov	 ah,00H                  
                                   ;	
                                   ;	    int 16H                     /* 16H -> servicios BIOS de teclado        */
                                   ;	
00000087  CD16                  	int	 16H                     
                                   ;	
                                   ;	//  mov car,al                  /* El caracter ascii se nos devuelve en AL */
                                   ;	  }
                                   ;	//return(car) ;
                                   ;	  return(_AL) ;
                                   ;	
                                   ;	
                                   ;	}
                                   ;	
00000089                        	ret	
0000008A                        _leerTecla	endp
                                	assume	cs:_TEXT,ds:DGROUP
0000008A                        _leerSector	proc	near
                                   ;	
                                   ;	int leerSector ( word_t sectorLogico,
                                   ;	
0000008A  55                    	push	bp
0000008B  8BEC                  	mov	bp,sp
                                   ;	
                                   ;	//               byte_t unidad,
                                   ;					 pointer_t dir ) {
                                   ;						 
                                   ;	  sector = (sectorLogico % C_sectoresPorPista) + 1 ;
                                   ;	
0000008D  8B4604                	mov	ax,word ptr [bp+4]
00000090  BB1200                	mov	bx,18
00000093  33D2                  	xor	dx,dx
00000095  F7F3                  	div	bx
00000097  FEC2                  	inc	dl
00000099  88160102              	mov	byte ptr DGROUP:_sector,dl
                                   ;	
                                   ;	  cabeza = (sectorLogico / C_sectoresPorPista) % 2 ; 
                                   ;	
0000009D  8B4604                	mov	ax,word ptr [bp+4]
000000A0  BB1200                	mov	bx,18
000000A3  33D2                  	xor	dx,dx
000000A5  F7F3                  	div	bx
000000A7  2401                  	and	al,1
000000A9  A20202                	mov	byte ptr DGROUP:_cabeza,al
                                   ;	
                                   ;	  cilindro = sectorLogico / (C_sectoresPorPista*C_cabezas) ;  
                                   ;	
000000AC  8B4604                	mov	ax,word ptr [bp+4]
000000AF  BB2400                	mov	bx,36
000000B2  33D2                  	xor	dx,dx
000000B4  F7F3                  	div	bx
000000B6  A20302                	mov	byte ptr DGROUP:_cilindro,al
                                   ;	
                                   ;	  
                                   ;	  asm {
                                   ;		les bx,dir ;
                                   ;	
000000B9  C45E06                	les	 bx,[bp+6] 
                                   ;	
                                   ;		mov ch,cilindro ;
                                   ;	
000000BC  8A2E0302              	mov	 ch,DGROUP:_cilindro 
                                   ;	
                                   ;		mov cl,sector ;
                                   ;	
000000C0  8A0E0102              	mov	 cl,DGROUP:_sector 
                                   ;	
                                   ;	//  mov dl,unidad ;
                                   ;	    mov dl,C_unidad ;
                                   ;	
000000C4  B200                  	mov	 dl,000H 
                                   ;	
                                   ;	    mov dh,cabeza ;	
                                   ;	
000000C6  8A360202              	mov	 dh,DGROUP:_cabeza 
                                   ;	
                                   ;	    mov al,1 ;
                                   ;	
000000CA  B001                  	mov	 al,1 
                                   ;	
                                   ;	    mov ah,02h ;        /* 42H -> EXTENDED READ                            */
                                   ;	
000000CC  B402                  	mov	 ah,02h 
                                   ;	
                                   ;	    int 13h ;           /* http://hdebruijn.soo.dto.tudelft.nl/newpage/interupt/out-0700.htm#0651 */
                                   ;	
000000CE  CD13                  	int	 13h 
                                   ;	
                                   ;	    jc errorAlLeer ;    /* el flag de acarreo C se activa en caso de error */
                                   ;	
000000D0  7204                  	jc	short @5@12
                                   ;	
                                   ;	  }
                                   ;	  return(0) ;
                                   ;	
000000D2  33C0                  	xor	ax,ax
000000D4  5D                    	pop	bp
000000D5                        	ret	
000000D6                        @5@12:
                                   ;	
                                   ;	errorAlLeer:
                                   ;	  return(_AH) ;
                                   ;	
000000D6  8AC4                  	mov	al,ah
000000D8  B400                  	mov	ah,0
                                   ;	
                                   ;	}
                                   ;	
000000DA  5D                    	pop	bp
000000DB                        	ret	
000000DC                        _leerSector	endp
                                	assume	cs:_TEXT,ds:DGROUP
000000DC                        _incAddr	proc	near
                                   ;	
                                   ;	void incAddr ( address_t * p, word_t i ) {
                                   ;	
000000DC  55                    	push	bp
000000DD  8BEC                  	mov	bp,sp
                                   ;	
                                   ;	  if (i > (0xFFFF - p->offset)) p->segment += 0x1000 ;
                                   ;	
000000DF  8B5E04                	mov	bx,word ptr [bp+4]
000000E2  B8FFFF                	mov	ax,-1
000000E5  2B07                  	sub	ax,word ptr [bx]
000000E7  3B4606                	cmp	ax,word ptr [bp+6]
000000EA  7308                  	jae	short @6@3
000000EC  8B5E04                	mov	bx,word ptr [bp+4]
000000EF  8147020010            	add	word ptr [bx+2],4096
000000F4                        @6@3:
                                   ;	
                                   ;	  p->offset += i ;
                                   ;	
000000F4  8B5E04                	mov	bx,word ptr [bp+4]
000000F7  8B4606                	mov	ax,word ptr [bp+6]
000000FA  0107                  	add	word ptr [bx],ax
                                   ;	
                                   ;	}
                                   ;	
000000FC  5D                    	pop	bp
000000FD                        	ret	
000000FE                        _incAddr	endp
000000FE                        _TEXT	ends
00000000                        _DATA	segment word public 'DATA'
00000000                         	_DATA	 ENDS 
000000FE                         	_TEXT	 SEGMENT BYTE PUBLIC 'CODE' 
                                 	ASSUME	 CS:_TEXT,DS:DGROUP 
000000FE                         	_msg	 PROC NEAR 
000000FE  0A0D50425220502E50    	db	 0ah, 0dh, 'PBR P.P.L.R. (C) 2016', 0ah,  0ah,  0h 
00000118                         	_msg	 ENDP 
00000118                         	_TEXT	 ENDS 
                                 	public	 _msg 
00000000                         	_DATA	 SEGMENT WORD PUBLIC 'DATA' 
00000000                        _DATA	ends
00000118                        _TEXT	segment byte public 'CODE'
                                	assume	cs:_TEXT,ds:DGROUP
00000118                        _main	proc	near
                                   ;	
                                   ;	void main ( void ) {                                            /* CS = DS */
                                   ;	
00000118  56                    	push	si
00000119  57                    	push	di
                                   ;	
                                   ;	
                                   ;	  /* La reubicacion del PBR puede hacerse realizando un bucle de copia o   */
                                   ;	  /* volviendo a leer el primer sector del disco en la direccion de        */
                                   ;	  /* de destino. En principio es mas rapido hacer la copia si la CPU es    */
                                   ;	  /* suficientemente rapida, pero en simuladores lentos como emu8086 es    */
                                   ;	  /* mucho mas rapido la lectura del disco simulada que la copia. Otra     */
                                   ;	  /* ventaja de la lectura del disco es que requiere menos código que la   */
                                   ;	  /* copia lejana, lo que es un hecho muy a tener en cuenta.               */                 
                                   ;	
                                   ;	#if (FALSE)
                                   ;	
                                   ;	  origen = 0x0000 ;                                           /*   DS:0000 */
                                   ;	
                                   ;	  destinoLejano = (pointer_t)MK_FP(0x9000, 0x0000) ;          /* 9000:0000 */
                                   ;	
                                   ;	  for ( i = 0 ; i < tamPBR ; i++ )   /* reubicacion del sector de arranque */
                                   ;	    *destinoLejano++ = *origen++ ;
                                   ;	
                                   ;	/* *destinoLejano++ = *origen++ ; es preferible a la instruccion:          */
                                   ;	/* destinoLejano[i] = origen[i] ; ya que requiere el uso de si (push si)   */
                                   ;	
                                   ;	#endif ;
                                   ;	
                                   ;	  macroCopia(0x0000, 0x9000, 512) ;
                                   ;	
0000011A  BE0000                 	mov	 si,00000H 
0000011D  8BFE                   	mov	 di,si 
0000011F  B80090                 	mov	 ax,09000H 
00000122  8EC0                   	mov	 es,ax 
00000124  B90002                 	mov	 cx,512 
00000127  F3A4                   	rep movsb	 
                                   ;	
                                   ;	
                                   ;	#if (FALSE) 
                                   ;	  leerSector(0, /* C_unidad, */ (pointer_t)MK_FP(0x9000, 0x0000)) ; /* unidad 0x00 */
                                   ;	#endif
                                   ;	  
                                   ;	  asm {
                                   ;	    push 9000H                 /* Cedemos el control al sector de arranque */
                                   ;	
00000129  680090                	push	 9000H                 
                                   ;	
                                   ;	                                                              /* reubicado */
                                   ;	#if defined(JWASM) || defined(TASM32)
                                   ;	    push OFFSET reubicado
                                   ;	
0000012C  683301                	push	 OFFSET _reubicado
                                   ;	
                                   ;	#else
                                   ;	    mov ax,OFFSET reubicado
                                   ;	    push ax
                                   ;	#endif
                                   ;	    retf
                                   ;	
0000012F  CB                    	retf	
                                   ;	
                                   ;	  }
                                   ;	
                                   ;	}
                                   ;	
00000130  5F                    	pop	di
00000131  5E                    	pop	si
00000132                        	ret	
00000133                        _main	endp
                                	assume	cs:_TEXT,ds:DGROUP
00000133                        _reubicado	proc	near
                                   ;	
                                   ;	void reubicado ( void ) {
                                   ;	
                                   ;	
                                   ;	
                                   ;	  asm {                   /* establecemos el segmento de datos DS igual CS */
                                   ;	    push cs ;
                                   ;	
00000133  0E                    	push	 cs 
                                   ;	
                                   ;	    pop ds ;
                                   ;	
00000134  1F                    	pop	 ds 
                                   ;	
                                   ;	  }
                                   ;	
                                   ;	//asm mov unidadBIOS,dl ;             /* el BIOS puso el numero de la unidad */
                                   ;	                                    /* de la que arranca en el registro DL */
                                   ;	//if (unidadBIOS != bpb.unidad) {
                                   ;	//if (C_unidad != bpb.unidad) {
                                   ;	#if (TRUE)
                                   ;	  if (_DL != bpb.unidad) {
                                   ;	
00000135  3A162400              	cmp	dl,byte ptr DGROUP:_bpb+36
00000139  740B                  	je	short @8@5
                                   ;	
                                   ;	    printCar('E') ;
                                   ;	
0000013B  6A45                  	push	69
0000013D  E80EFF                	call	near ptr _printCar
00000140  59                    	pop	cx
                                   ;	
                                   ;	    leerTecla() ;
                                   ;	
00000141  E841FF                	call	near ptr _leerTecla
                                   ;	
                                   ;	    rebootBIOS() ;
                                   ;	
00000144  CD19                   	int	 19h 
00000146                        @8@5:
                                   ;	
                                   ;	  }
                                   ;	#endif
                                   ;	
                                   ;	//resetController() ;              /* se supone ya hecho por parte del MBR */
                                   ;	
                                   ;	              /* Cargar el S.O. a partir de la dirección 0600H escribiendo */
                                   ;	              /* un punto tras la lectura de cada sector                   */
                                   ;	
                                   ;	  entrada = (entrada_t far *)MK_FP(0x9000, 0x0300) ;           /* ojo: BSS */
                                   ;	
00000146  C70608020090          	mov	word ptr DGROUP:_entrada+2,-28672
0000014C  C70606020003          	mov	word ptr DGROUP:_entrada,768
                                   ;	
                                   ;	
                                   ;	  ptr = (pointer_t)MK_FP(0x0060, 0x0000) ;           /* 0060:0000 = 00600H */
                                   ;	
00000152  C7060C026000          	mov	word ptr DGROUP:_ptr+2,96
00000158  C7060A020000          	mov	word ptr DGROUP:_ptr,0
                                   ;	
                                   ;	
                                   ;	  sectorlogico = C_primerSectorDatos ;           /* primer sector de datos */
                                   ;	
0000015E  C7060E022100          	mov	word ptr DGROUP:_sectorlogico,33
                                   ;	
                                   ;	
                                   ;	  leerSector(C_primerSectorDirRaiz, /* _DL, */ (pointer_t)entrada) ;
                                   ;	
00000164  FF360802              	push	word ptr DGROUP:_entrada+2
00000168  FF360602              	push	word ptr DGROUP:_entrada
0000016C  6A13                  	push	19
0000016E  E819FF                	call	near ptr _leerSector
00000171  83C406                	add	sp,6
                                   ;	
                                   ;	  nsects = (entrada[0].tam.reg.med/2)+1 ;
                                   ;	
00000174  C41E0602              	les	bx,dword ptr DGROUP:_entrada
00000178  268B471D              	mov	ax,word ptr es:[bx+29]
0000017C  D1E8                  	shr	ax,1
0000017E  40                    	inc	ax
0000017F  A31002                	mov	word ptr DGROUP:_nsects,ax
                                   ;	
                                   ;	
                                   ;	/* grldr (0.4.4)  funciona, aunque no detecta el fichero de configuracion  */
                                   ;	/*   menu.lst hasta que no se ejecuta el comando: root (fd0). (3 MB Ok).   */
                                   ;	/* grldr (0.4.5c) funciona si cuenta con al menos 35 megas de RAM.         */
                                   ;	/* grldr (0.4.6a) no funciona con BOOT_9 (usar bootlace).                  */
                                   ;	
                                   ;	#if (TRUE)
                                   ;	  printStrMacro(msg) ;
                                   ;	
00000182  68FE00                 	push	 offset _msg 
00000185  E8D2FE                 	call	 near ptr _printStr 
00000188  59                     	pop	 cx 
                                   ;	
                                   ;	#else
                                   ;	  printStr((char *)msg) ;
                                   ;	#endif
                                   ;	
                                   ;	  for ( i = 0 ; i < nsects ; i++ ) {
                                   ;	
00000189  C70604020000          	mov	word ptr DGROUP:_i,0
0000018F  EB2C                  	jmp	short @8@12
00000191                        @8@10:
                                   ;	
                                   ;	    leerSector(sectorlogico++, /* C_unidad, */ ptr) ;       /* unidad 0x00 */
                                   ;	
00000191  FF360C02              	push	word ptr DGROUP:_ptr+2
00000195  FF360A02              	push	word ptr DGROUP:_ptr
00000199  A10E02                	mov	ax,word ptr DGROUP:_sectorlogico
0000019C  FF060E02              	inc	word ptr DGROUP:_sectorlogico
000001A0  50                    	push	ax
000001A1  E8E6FE                	call	near ptr _leerSector
000001A4  83C406                	add	sp,6
                                   ;	
                                   ;	    printCar('.') ;
                                   ;	
000001A7  6A2E                  	push	46
000001A9  E8A2FE                	call	near ptr _printCar
000001AC  59                    	pop	cx
                                   ;	
                                   ;	    incAddr((address_t *)&ptr, C_bytesPorSector) ;
                                   ;	
000001AD  680002                	push	512
000001B0  680A02                	push	offset DGROUP:_ptr
000001B3  E826FF                	call	near ptr _incAddr
000001B6  83C404                	add	sp,4
000001B9  FF060402              	inc	word ptr DGROUP:_i
000001BD                        @8@12:
000001BD  A10402                	mov	ax,word ptr DGROUP:_i
000001C0  3B061002              	cmp	ax,word ptr DGROUP:_nsects
000001C4  72CB                  	jb	short @8@10
                                   ;	
                                   ;	  }
                                   ;	
                                   ;	  asm {
                                   ;	//  mov dl,unidadBIOS ; /* Transmitimos el numero de la unidad de arranque */
                                   ;	    mov dl,C_unidad ;   /* Transmitimos el numero de la unidad de arranque */
                                   ;	
000001C6  B200                  	mov	 dl,000H 
                                   ;	
                                   ;	    push 0060H ;      /* Cedemos el control al S.O. en 0060:0000 = 000600H */
                                   ;	
000001C8  6A60                  	push	 0060H 
                                   ;	
                                   ;	    push 0000H ;
                                   ;	
000001CA  6A00                  	push	 0000H 
                                   ;	
                                   ;	    retf ;
                                   ;	
000001CC  CB                    	retf	 
                                   ;	
                                   ;	  }
                                   ;	
                                   ;	  asm org 0x1FF ;
                                   ;	
                                 	org	 01FFH 
                                   ;	
                                   ;	
                                   ;	}
                                   ;	
000001FF                        	ret	
00000200                        _reubicado	endp
00000200                        _TEXT	ends
00000000                        _BSS	segment word public 'BSS'
00000000                        _bpb	label	word
00000000  000000000000000000    	db	62 dup (?)
0000003E                        _codigo	label	byte
0000003E  000000000000000000    	db	448 dup (?)
000001FE                        _signaturaPBR	label	byte
000001FE  0000                  	db	2 dup (?)
00000200                        _error	label	byte
00000200  00                    	db	1 dup (?)
00000201                        _sector	label	byte
00000201  00                    	db	1 dup (?)
00000202                        _cabeza	label	byte
00000202  00                    	db	1 dup (?)
00000203                        _cilindro	label	byte
00000203  00                    	db	1 dup (?)
00000204                        _i	label	word
00000204  0000                  	db	2 dup (?)
00000206                        _entrada	label	dword
00000206  00000000              	db	4 dup (?)
0000020A                        _ptr	label	dword
0000020A  00000000              	db	4 dup (?)
0000020E                        _sectorlogico	label	word
0000020E  0000                  	db	2 dup (?)
00000210                        _nsects	label	word
00000210  0000                  	db	2 dup (?)
00000212                        _BSS	ends
00000000                        _DATA	segment word public 'DATA'
00000000                        s@	label	byte
00000000                        _DATA	ends
00000200                        _TEXT	segment byte public 'CODE'
00000200                        _TEXT	ends
                                	public	_bootCode
                                	public	_bpb
                                	public	_codigo
                                	public	_signaturaPBR
                                	public	_main
                                	public	_printCar
                                	public	_printStr
                                	public	_leerTecla
                                	public	_error
                                	public	_sector
                                	public	_cabeza
                                	public	_cilindro
                                	public	_leerSector
                                	public	_incAddr
                                	public	_reubicado
                                	public	_i
                                	public	_entrada
                                	public	_ptr
                                	public	_sectorlogico
                                	public	_nsects
                                	end


Macros:

                N a m e                 Type

$comm  . . . . . . . . . . . . .        Proc
@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

$$SYMBOLS  . . . . . . . . . . .        32 Bit   00000276 Byte    Private 'DEBSYM'
$$TYPES  . . . . . . . . . . . .        32 Bit   00000004 Byte    Private 'DEBTYP'
_TEXT  . . . . . . . . . . . . .        16 Bit   0200     Byte    Public  'CODE'
DGROUP . . . . . . . . . . . . .        GROUP
_DATA  . . . . . . . . . . . . .        16 Bit   0000     Word    Public  'DATA'
_BSS . . . . . . . . . . . . . .        16 Bit   0212     Word    Public  'BSS'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

_bootCode  . . . . . . . . . . .        P Near   003E     _TEXT    0010 Public   
_incAddr . . . . . . . . . . . .        P Near   00DC     _TEXT    0022 Public   
_leerSector  . . . . . . . . . .        P Near   008A     _TEXT    0052 Public   
_leerTecla . . . . . . . . . . .        P Near   0085     _TEXT    0005 Public   
_main  . . . . . . . . . . . . .        P Near   0118     _TEXT    001B Public   
_msg . . . . . . . . . . . . . .        P Near   00FE     _TEXT    001A Public   
_printCar  . . . . . . . . . . .        P Near   004E     _TEXT    000C Public   
_printStr  . . . . . . . . . . .        P Near   005A     _TEXT    002B Public   
_reubicado . . . . . . . . . . .        P Near   0133     _TEXT    00CD Public   
_startBin  . . . . . . . . . . .        P Near   0000     _TEXT    003E Public   


Symbols:

                N a m e                 Type       Value     Attr

??version  . . . . . . . . . . .        Text   0504
?debug . . . . . . . . . . . . .        Text   ;
@3@2 . . . . . . . . . . . . . .        L Near            60h _TEXT 
@3@4 . . . . . . . . . . . . . .        L Near            6Ch _TEXT 
@3@5 . . . . . . . . . . . . . .        L Near            74h _TEXT 
@5@12  . . . . . . . . . . . . .        L Near            D6h _TEXT 
@6@3 . . . . . . . . . . . . . .        L Near            F4h _TEXT 
@8@10  . . . . . . . . . . . . .        L Near           191h _TEXT 
@8@12  . . . . . . . . . . . . .        L Near           1BDh _TEXT 
@8@5 . . . . . . . . . . . . . .        L Near           146h _TEXT 
_bpb . . . . . . . . . . . . . .        Word               0h _BSS Public 
_cabeza  . . . . . . . . . . . .        Byte             202h _BSS Public 
_cilindro  . . . . . . . . . . .        Byte             203h _BSS Public 
_codigo  . . . . . . . . . . . .        Byte              3Eh _BSS Public 
_entrada . . . . . . . . . . . .        DWord            206h _BSS Public 
_error . . . . . . . . . . . . .        Byte             200h _BSS Public 
_i . . . . . . . . . . . . . . .        Word             204h _BSS Public 
_nsects  . . . . . . . . . . . .        Word             210h _BSS Public 
_ptr . . . . . . . . . . . . . .        DWord            20Ah _BSS Public 
_sector  . . . . . . . . . . . .        Byte             201h _BSS Public 
_sectorlogico  . . . . . . . . .        Word             20Eh _BSS Public 
_signaturaPBR  . . . . . . . . .        Byte             1FEh _BSS Public 
b@ . . . . . . . . . . . . . . .        Byte               0h _BSS 
b@w  . . . . . . . . . . . . . .        Word               0h _BSS 
d@ . . . . . . . . . . . . . . .        Byte               0h _DATA 
d@w  . . . . . . . . . . . . . .        Word               0h _DATA 
s@ . . . . . . . . . . . . . . .        Byte               0h _DATA 

pbrfat12.asm: 657 lines, 3 passes, 0 ms, 0 warnings, 0 errors
